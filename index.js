const express = require('express');
const bodyParser = require('body-parser');
const app = express();
const port = process.env.PORT || 3000;
const axios = require('axios');
const { connectToDb, getDb } = require('./db');
const TronWeb = require('tronweb');
const TelegramBot = require('node-telegram-bot-api');
const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: true });
const BigNumber = require('bignumber.js');

const tronWeb = new TronWeb({
    fullHost: 'https://api.trongrid.io'
});
app.use(bodyParser.json());
const cors=require("cors");
const path = require("path");
const corsOptions ={
    origin:'*',
    credentials:true,
    optionSuccessStatus:200,
}


app.use(cors(corsOptions))


app.post('/auth', async (req, res) => {
    const { telegramId, username } = req.body;

    const Wallet = await createNewAccount();
    let usdtInfo = 0;
    let balanceInfo = 0;
    let canDedInfo = 0;

    const db = getDb();
    if (!db) {
        return res.status(500).json({ message: 'Database connection error' });
    }

    const usersCollection = db.collection('users');

    try {
        const existingUser = await usersCollection.findOne({ telegramId });
        console.log('existingUser:', existingUser);

        if (!existingUser) {
            const newUser = { telegramId, username, Wallet,usdtInfo,balanceInfo,canDedInfo };
            await usersCollection.insertOne(newUser);
            console.log('New User:', newUser);
            return res.json({ message: 'Ğ’Ğ°Ñˆ ID Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
        } else {
            return res.json({ message: 'Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
        }
    } catch (error) {
        console.error('Error handling user data:', error);
        return res.status(500).json({ message: 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.' });
    }
});

app.post(`/bot${process.env.BOT_TOKEN}`, (req, res) => {
    try {
        processUpdate(req.body);
        res.sendStatus(200);
    } catch (error) {
        console.error('Error processing update:', error);
        res.sendStatus(500);
    }
});


const getWallet = async (telegramId) => {
    let db;
    try {
        db = getDb();
        console.log("Database object:", db);
    } catch (error) {
        console.error('Error getting database:', error.message);
        return null;
    }
    const usersCollection = db.collection('users');

    try {
        const user = await usersCollection.findOne({ telegramId: parseFloat(telegramId) });

        if (!user) {
            console.log("User not found");
            return null;
        }

        if (user.Wallet && user.Wallet.address && user.Wallet.address.base58) {
            return user.Wallet.address.base58;
        } else {
            console.log('Wallet structure is missing expected fields');
            return null;
        }
    } catch (err) {
        console.error('Error fetching user wallet:', err);
        return null;
    }
};


app.post('/api/wallet', async (req, res) => {
    const { telegramId } = req.body;
    const base58 = await getWallet(telegramId);

    if (base58) {
        res.json({ base58 });
    } else {
        res.status(404).json({ error: 'Wallet not found' });
    }
});


connectToDb((err) => {
    if (err) {
        console.error('Failed to connect to database');
        return;
    }
    app.listen(port, () => {

        console.log(`Server running on :${port}`);


    });
});



//getBalance('TT3GQycpjchooQ7CuV3zivJ4bF2Zi2jEJ8').then(balance => console.log('Balance:', balance/1000000));


app.get('/api/info', async (req, res) => {
    const telegramId = req.headers['x-telegram-id'];

    if (!telegramId) {
        return res.status(400).json({ message: 'ĞĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ telegramId.' });
    }

    const db = getDb();
    if (!db) {
        return res.status(500).json({ message: 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
    }

    const usersCollection = db.collection('users');

    try {
        const user = await usersCollection.findOne({ telegramId: parseFloat(telegramId) });

        if (!user) {
            return res.status(404).json({ message: 'ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.' });
        }

        const { usdtInfo, balanceInfo, canDedInfo } = user;

        // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
        const formattedUsdtInfo = usdtInfo.$numberInt || usdtInfo;
        const formattedBalanceInfo = balanceInfo.$numberInt || balanceInfo;
        const formattedCanDedInfo = canDedInfo.$numberInt || canDedInfo;

        res.json({
            usdtInfo: formattedUsdtInfo,
            balanceInfo: formattedBalanceInfo,
            canDedInfo: formattedCanDedInfo
        });
    } catch (error) {
        console.error('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:', error);
        return res.status(500).json({ message: 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.' });
    }
});


// app.post('/api/update', async (req, res) => {
//     const { amount } = req.body;
//
//     if (amount <= 0 || isNaN(amount)) {
//         return res.status(400).json({ error: 'Invalid amount' });
//     }
//
//     usdtInfo += amount;
//     balanceInfo += amount;
//     canDedInfo += amount;
//
//     res.json({ success: true, usdtInfo, balanceInfo, canDedInfo });
//
// });

//TO DO

app.post('/send-to-wallet', async (req, res) => {
    const walletAddress = req.body.address;
    const amount = req.body.amount;
    const telegramId = req.body.telegramId;

    if (!walletAddress) {
        return res.status(400).json({ success: false, message: 'ĞĞ´Ñ€ĞµÑ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ° Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½.' });
    }

    const db = getDb();
    if (!db) {
        return res.status(500).json({ message: 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
    }

    const usersCollection = db.collection('users');

    try {
        const user = await usersCollection.findOne({ telegramId: parseFloat(telegramId) });

        if (!user) {
            return res.status(404).json({ message: 'ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.' });
        }

        // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ñ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğ¼Ğ¸ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ÑĞ¼Ğ¸
        let { usdtInfo , balanceInfo, canDedInfo } = user;

        // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
        usdtInfo = Number(usdtInfo);
        balanceInfo = Number(balanceInfo);
        canDedInfo = Number(canDedInfo);
//commint to github amount >=10!!!
        if (canDedInfo >= amount && amount >= 10) {
            balanceInfo -= amount;
            canDedInfo -= amount;
            usdtInfo -= amount;

            // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            await usersCollection.updateOne(
                { telegramId: parseFloat(telegramId) },
                {
                    $set: {
                        balanceInfo,
                        canDedInfo,
                        usdtInfo
                    }
                }
            );

            res.json({
                success: true,
                message: `Ğ¡Ñ€ĞµĞ´ÑÑ‚Ğ²Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑ: ${walletAddress}.`,
                balanceInfo,
                canDedInfo,
                usdtInfo
            });
        } else {
            res.json({ success: false, message: 'ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ² Ğ´Ğ»Ñ ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ.' });
        }
    } catch (error) {
        console.error('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:', error);
        return res.status(500).json({ message: 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.' });
    }

    //TO:DO Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ¾ÑˆĞµĞ»ĞµĞº, ĞµÑ‰Ğµ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ´ÑƒĞ¼Ğ°Ğ½


});

app.post('/proofofpayment', async (req, res) => {
    const walletAddress = req.body.address;
    const telegramId = req.body.telegramId;
    const expectedAmount = parseFloat(req.body.amount); // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ² Ñ‡Ğ¸ÑĞ»Ğ¾

    try {
        const privateKey = await getPrivateKeyByAddress(telegramId);
        if (!privateKey) {
            return res.status(400).json({ error: 'Invalid wallet address or private key not found' });
        }

        const transactions = await getTransactionsByAddress(walletAddress);
        if (transactions) {
            const parsedTransaction = parseTransaction(transactions);

            if (parsedTransaction && parseFloat(parsedTransaction.amount) === expectedAmount) {
                const db = getDb();
                if (!db) {
                    return res.status(500).json({ message: 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
                }

                const txIdCollection = db.collection('txId');
                const usersCollection = db.collection('users');

                try {
                    const existingTxId = await txIdCollection.findOne({ TxID: parsedTransaction.txID });
                    if (!existingTxId) {
                        const newTxId = { TxID: parsedTransaction.txID };
                        await txIdCollection.insertOne(newTxId);
                        console.log('New txid:', newTxId);

                        const user = await usersCollection.findOne({ telegramId: parseFloat(telegramId) });
                        if (!user) {
                            return res.status(404).json({ message: 'ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.' });
                        }

                        let { usdtInfo, balanceInfo, canDedInfo } = user;
                        usdtInfo = Number(usdtInfo);
                        balanceInfo = Number(balanceInfo);
                        canDedInfo = Number(canDedInfo);

                        if (expectedAmount >= 50) {
                            balanceInfo += expectedAmount;
                            canDedInfo += expectedAmount;
                            usdtInfo += expectedAmount;

                            await usersCollection.updateOne(
                                { telegramId: parseFloat(telegramId) },
                                {
                                    $set: {
                                        balanceInfo,
                                        canDedInfo,
                                        usdtInfo
                                    }
                                }
                            );
                            await sendPaymentConfirmation(telegramId, newTxId, expectedAmount)

                            return res.json({
                                success: true,
                                message: `Ğ¡Ñ€ĞµĞ´ÑÑ‚Ğ²Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑ: ${walletAddress}.`,
                                balanceInfo,
                                canDedInfo,
                                usdtInfo
                            });
                        } else {
                            return res.json({ success: false, message: 'ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ² Ğ´Ğ»Ñ ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ.' });
                        }
                    } else {
                        return res.json({ message: 'Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ°Ğ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….' });
                    }
                } catch (error) {
                    console.error('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ:', error);
                    return res.status(500).json({ message: 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.' });
                }
            } else {
                return res.status(400).json({ error: 'Payment amount does not match' });
            }
        } else {
            return res.status(404).json({ error: 'No transactions found for the address' });
        }
    } catch (error) {
        console.error('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°:', error);
        return res.status(500).json({ error: 'Internal server error' });
    }
});

async function getTransactionsByAddress(base58Address) {
    try {
        const addressHex = tronWeb.address.toHex(base58Address);
        const response = await axios.get(`https://api.trongrid.io/v1/accounts/${addressHex}/transactions`);
        const transactions = response.data;
        if (transactions && transactions.data && transactions.data.length > 0) {
            return transactions.data[0];
        } else {
            console.log('ĞĞµÑ‚ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹.');
            return null;
        }
    } catch (error) {
        console.error('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹:', error);
        return null;
    }
}

function parseTransaction(transaction) {
    if (transaction.raw_data && transaction.raw_data.contract) {
        for (const contract of transaction.raw_data.contract) {
            if (contract.parameter && contract.parameter.value) {
                const contractData = contract.parameter.value;

                if (contract.type === 'TriggerSmartContract') {
                    const methodId = contractData.data.slice(0, 8);
                    if (methodId === 'a9059cbb') { // ĞœĞµÑ‚Ğ¾Ğ´ transfer(address,uint256)
                        const fromAddress = tronWeb.address.fromHex(contractData.owner_address);
                        const toAddressHex = '41' + contractData.data.slice(8, 72);
                        const toAddress = tronWeb.address.fromHex(toAddressHex);
                        const amountHex = contractData.data.slice(72, 136); // ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ ÑÑƒĞ¼Ğ¼Ñ‹ (64 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°)

                        // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ğ² USDT (Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ÑÑ 6 Ğ´ĞµÑÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ·Ğ½Ğ°ĞºĞ¾Ğ²)
                        const amount = new BigNumber(amountHex, 16).dividedBy(1e6);
                        return {
                            txID: transaction.txID,
                            fromAddress,
                            toAddress,
                            amount: amount.toFixed()
                        };
                    }
                }
            }
        }
    } else {
        console.log('Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹.');
    }
    return null;
}

async function sendPaymentConfirmation(telegramId, txID, amount) {
    const bot = new TelegramBot(process.env.BOT_TOKEN_ALERT);
    const message = `
ğŸš€ New Staked amount Boost ğŸš€

ğŸ’° Amount: ${amount} USDT
ğŸ‘¤ User:  ${telegramId}

`;
    const options = {
        parse_mode: 'Markdown',
        message_thread_id: 5,
        reply_markup: {
            inline_keyboard: [
                [{ text: 'ğŸš€ Start App ğŸš€', url: 'https://example.com/start-app' }],
                [{ text: 'ğŸ Join Community! ğŸ', url: 'https://example.com/join-community' }],
                [{ text: 'TXID', url: `https://tronscan.org/#/transaction/${txID}` }],
            ]
        }
    };
    bot.sendMessage(-1002220861636, message, options);

}
async function getPrivateKeyByAddress(address) {

    const db = getDb();
    if (!db) {
        return console.log('some mistakes,database not found')
    }
    const usersCollection = db.collection('users');
    try {
        const user = await usersCollection.findOne({telegramId: parseFloat(address)});

        if (!user) {
            console.log("User not found");
            return null;
        }

        if (user.Wallet && user.Wallet.privateKey ) {
            return user.Wallet.privateKey;
        } else {
            console.log('Wallet structure is missing expected fields');
            return null;
        }
    } catch (err) {
        console.error('Error fetching user wallet:', err);
        return null;
    }

}




async function getBalance(address) {
    try {
        const response = await axios.get(`https://api.trongrid.io/v1/accounts/${address}`);
        if (response.data && response.data.data && response.data.data.length > 0) {
            const accountData = response.data.data[0]; // ĞŸĞµÑ€Ğ²Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            if (accountData.balance !== undefined) {
                return accountData.balance;
            } else {
                console.error('Balance not found in account data:', accountData);
                return 'Balance not found';
            }
        } else {
            console.error('No data found in response:', response.data);
            return 'No data found';
        }
    } catch (error) {
        console.error('Error fetching balance:', error);
        return 'Error fetching balance';
    }
}
async function createNewAccount() {
    try {
        const newAccount = await tronWeb.createAccount();
        console.log('New Account:', newAccount);
        return newAccount; // Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚Ğµ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚
    } catch (error) {
        console.error('Error creating account:', error);
        throw error; // ĞŸÑ€Ğ¾Ğ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ, ĞµÑĞ»Ğ¸ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚
    }
}


//bot section=======================================

app.post(`/bot${process.env.BOT_TOKEN}`, (req, res) => {
    try {
        processUpdate(req.body);
        res.sendStatus(200);
    } catch (error) {
        console.error('Error processing update:', error);
        res.sendStatus(500);
    }
});
const sendWelcomeMessage = (chatId) => {
    const photoUrl = path.join(__dirname, 'logo.png');
    const message = `
    <b>Welcome to</b> <b><u>USDTStaking App</u></b>
    <b>Stack-To-Earn</b>

    Welcome, <a href="https://t.me/usdtstaking_news">USDTStaking App</a>! ğŸ¤

    ğŸš€ <b>Discover the revolutionary Stack-To-Earn app built on Telegram!</b>

    Experience limitless opportunities for Stake USDT. Our infrastructure, powered by TRON blockchain, ensures optimized transactions and reduced transfer fees.

    Be among the pioneers in earning with Tonix!

    Complete missions, invite friends, rent additional mining power to earn even more.

    Don't miss the opportunity to increase your income and strive for financial independence with us! ğŸ’°ğŸš€

    <b>Tap Start App ğŸ‘‡</b>
    `;

    const options = {
        parse_mode: 'HTML',
        reply_markup: {
            inline_keyboard: [
                [
                    { text: 'âš¡ Start App âš¡', web_app: { url: 'https://66afb02aa7f4c7c3d41e2066--luxury-narwhal-b92ac9.netlify.app/' } },
                ],
                [
                    { text: 'ğŸ Join Community! ğŸ', url: 'https://t.me/usdtstaking_group/1' }
                ]
            ]
        }
    };

    bot.sendPhoto(chatId, photoUrl, { caption: message, ...options })
        .catch(error => {
            console.error('Error sending photo:', error);
        });
};

bot.on('message', (msg) => {
    const chatId = msg.chat.id;
    sendWelcomeMessage(chatId);
});

// ===========================================================================
